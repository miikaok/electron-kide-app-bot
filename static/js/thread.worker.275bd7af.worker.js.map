{"version":3,"file":"static/js/thread.worker.275bd7af.worker.js","mappings":"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","sources":["logic/thread.worker.js"],"sourcesContent":["// Original filename: thread.worker.js\r\n\r\nAbortSignal.timeout ??= function timeout(ms) {\r\n  const ctrl = new AbortController();\r\n  setTimeout(() => ctrl.close(), ms);\r\n  return ctrl.signal;\r\n};\r\n\r\n/**\r\n * Fetches the event data for a given event ID from the Kide API.\r\n *\r\n * @param {string} eventID - The ID of the event to fetch data for.\r\n * @param {number} [requestTimeout=5000] - Timeout for the request in milliseconds (default is 5000ms).\r\n *\r\n * @returns {Promise<Object|null>} Returns a promise that resolves to the event data object if successful, or `null` if an error occurred.\r\n * The returned object will contain the event details, including variants and other information.\r\n * If the response status is not 200, the function returns `null`.\r\n *\r\n * @throws {Error} Throws an error if the fetch request fails, which is caught and logged within the function.\r\n *\r\n * @example\r\n * getEventData('123', 3000)\r\n *   .then(eventData => console.log(eventData))\r\n *   .catch(error => console.error('An error occurred:', error));\r\n */\r\nconst getEventInformation = async (eventID, requestTimeout = 5000) => {\r\n  try {\r\n    const response = await fetch(`https://api.kide.app/api/products/${eventID}`, {\r\n      method: \"GET\",\r\n      headers: {\r\n        \"cache-control\": \"no-cache\",\r\n      },\r\n      signal: AbortSignal.timeout(requestTimeout),\r\n    });\r\n\r\n    if (response.ok) return response.json();\r\n  } catch (error) {\r\n    console.error(`Error fetching event data for eventID ${eventID}:`, error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Calculates an encoded ID based on the given inventory ID and a constant EXTRA_ID.\r\n * The function performs bitwise XOR operation between the ASCII codes of each character in the stripped inventory ID and EXTRA_ID.\r\n * The result is then base64 encoded and truncated to 10 characters.\r\n * \r\n * @param {string} inventoryId The original inventory ID, which may contain hyphens.\r\n * @returns {string} Returns a base64 encoded, truncated string derived from bitwise XOR operation.\r\n * @throws {Error} Throws an error if the inventoryId is not a string or if it's empty.\r\n * @example\r\n * const xRequestedId = calculateXRequestedId('1234-5678');\r\n * console.log(xRequestedId); // Output: \"encodedString\"\r\n * @credits Special acknowledgment to Aleksi Virkkala for providing an open-source solution that contributed to this function. For more details, visit [Aleksi Virkkala's GitHub Profile](https://github.com/AleksiVirkkala).\r\n*/\r\nconst calculateXRequestedId = (inventoryId) => {\r\n  if (typeof inventoryId !== \"string\" || inventoryId.length === 0) {\r\n    throw new Error(\"Invalid inventoryId. Must be a non-empty string.\");\r\n  }\r\n\r\n  const strippedId = inventoryId.replace(/-/g, \"\");\r\n  const EXTRA_ID = \"2ad64e4b26c84fbabba58181de76f7b0\";\r\n\r\n  if (strippedId.length !== EXTRA_ID.length) {\r\n    throw new Error(\"Length of strippedId and EXTRA_ID must be the same.\");\r\n  }\r\n\r\n  let encodedString = \"\";\r\n\r\n  for (let i = 0; i < strippedId.length; i++) {\r\n    const xorResult = strippedId.charCodeAt(i) ^ EXTRA_ID.charCodeAt(i);\r\n    encodedString += String.fromCharCode(xorResult);\r\n  }\r\n\r\n  return btoa(encodedString).substring(0, 10);\r\n};\r\n\r\n\r\n/**\r\n * Gets the current user's reservation data (shopping cart) from the Kide API\r\n * @param {string} bearerToken Bearer token used to authenticate the request\r\n * @param {number} requestTimeout Timeout for the request in milliseconds\r\n * @returns {null | string[]} Returns null if an error occurred, otherwise returns an array of inventory IDs\r\n * @throws {Error} Throws an error if the fetch request fails\r\n * @example\r\n * const reservations = await getReservationData(bearerToken: 'your-token-here', requestTimeout: 3000);\r\n * console.log(reservations); // Output: ['inventoryId1', 'inventoryId2', ...]\r\n */\r\nconst getReservationState = async ({ bearerToken, requestTimeout = 5000 }) => {\r\n  try {\r\n    const response = await fetch(\"https://api.kide.app/api/reservations\", {\r\n      method: \"GET\",\r\n      headers: {\r\n        Authorization: `Bearer ${bearerToken}`,\r\n        cache: \"no-cache\",\r\n      },\r\n      signal: AbortSignal.timeout(requestTimeout),\r\n    });\r\n\r\n    if (response.ok) {\r\n      const responseBody = await response.json();\r\n      const reservations = responseBody.model?.reservations;\r\n\r\n      if (reservations == null) return [];\r\n\r\n      const itemsInCart = reservations.map((reservation) => reservation.inventoryId);\r\n      return itemsInCart;\r\n    } else {\r\n      console.error(`Error fetching reservations: ${response.status} ${response.statusText}`);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"An error occurred while fetching reservations:\", error);\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Creates a reservation for a product variant\r\n * @param {string} bearerToken Bearer token used to authenticate the request\r\n * @param {string} inventoryId Inventory ID of the product variant\r\n * @param {number} quantity Quantity of the product variant to reserve\r\n * @param {number} requestTimeout Timeout for the request in milliseconds\r\n * @returns {boolean} Returns true if the reservation was successful, otherwise returns false\r\n * @example\r\n * const reservationSuccess = await createProductVariantReservation({\r\n      bearerToken: 'your-token-here',\r\n      inventoryId: 'inventory-id-here',\r\n      quantity: 3,\r\n      requestTimeout: 3000,\r\n    });\r\n * console.log(reservationSuccess); // Output: true\r\n */\r\nconst createProductVariantReservation = async ({\r\n  bearerToken,\r\n  inventoryId,\r\n  quantity,\r\n  requestTimeout,\r\n}) => {\r\n  const response = await fetch(\"https://api.kide.app/api/reservations\", {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json;charset=UTF-8\",\r\n      \"accept\": \"application/json, text/plain, */*\",\r\n      \"x-requested-id\": calculateXRequestedId(inventoryId),\r\n      Authorization: `Bearer ${bearerToken}`,\r\n    },\r\n    body: JSON.stringify({\r\n      expectCart: true,\r\n      toCancel: null,\r\n      toCreate: [\r\n        {\r\n          inventoryId: inventoryId,\r\n          quantity: quantity,\r\n        },\r\n      ],\r\n    }),\r\n    signal: AbortSignal.timeout(requestTimeout),\r\n  });\r\n  return response.ok;\r\n};\r\n\r\n/**\r\n * Reserves a product variant\r\n * @param {string} bearerToken Bearer token used to authenticate the request\r\n * @param {number} requestTimeout Timeout for the request in milliseconds\r\n * @param {object} variant Product variant object\r\n * @param {boolean} useCustomCount Whether to use a custom ticket count\r\n * @param {number} ticketBuyCount Custom ticket count\r\n * @returns {undefined} The function does not return value\r\n */\r\nconst reserveProductVariant = async ({\r\n  bearerToken,\r\n  requestTimeout = 5000,\r\n  variant,\r\n  useCustomCount = false,\r\n  ticketBuyCount = 0,\r\n} = {}) => {\r\n  try {\r\n    const maxReservationCount = Math.min(\r\n      variant.availability,\r\n      variant.productVariantMaximumReservableQuantity\r\n    );\r\n\r\n    if (maxReservationCount === 0) return self.postMessage({ type: \"buy_failed\" });\r\n\r\n    const cart = await getReservationState({\r\n      bearerToken: bearerToken,\r\n      requestTimeout: requestTimeout,\r\n    });\r\n\r\n    // If the cart is null the request has failed, return\r\n    if (cart === null || typeof cart === \"undefined\") {\r\n      return self.postMessage({ type: \"request_error\" });\r\n    } else {\r\n      self.postMessage({ type: \"request_success\" });\r\n    }\r\n\r\n    // If the item is already in the cart, return\r\n    if (cart.includes(variant.inventoryId)) return self.postMessage({ type: \"in_cart\" });\r\n\r\n    const quantity = useCustomCount\r\n      ? Math.min(ticketBuyCount, maxReservationCount)\r\n      : maxReservationCount;\r\n\r\n    // Attempt to reserve the item\r\n    const reservationSuccess = await createProductVariantReservation({\r\n      bearerToken: bearerToken,\r\n      inventoryId: variant.inventoryId,\r\n      quantity: quantity,\r\n      requestTimeout: requestTimeout,\r\n    });\r\n\r\n    // If the reservation failed, return\r\n    if (!reservationSuccess) return self.postMessage({ type: \"buy_failed\" });\r\n\r\n    // The reservation was successful\r\n    self.postMessage({ type: \"buy_success\" });\r\n  } catch (error) {\r\n    console.error(\"An error occurred while processing the shopping request:\", error);\r\n    self.postMessage({ type: \"buy_failed\" });\r\n  }\r\n};\r\n\r\n/**\r\n * Handles an event message by repeatedly attempting to reserve product variants.\r\n * The function first attempts to reserve priority items if provided, and then randomly selects available variants.\r\n * The interval for attempting reservations is controlled by the `threadDelay` parameter.\r\n *\r\n * @param {Object} event - The event object containing the data for handling the message.\r\n * @param {string} event.data.eventID - The ID of the event to handle.\r\n * @param {number} event.data.threadDelay - The delay in milliseconds between attempts to reserve product variants.\r\n * @param {number} event.data.requestTimeout - Timeout for the request in milliseconds.\r\n * @param {boolean} event.data.strictPriority - Whether to strictly follow priority items and skip others if priority items are present.\r\n * @param {Object[]} event.data.priorityItems - An array of priority items to be reserved first.\r\n * @param {string} event.data.bearerToken - Bearer token used to authenticate the request.\r\n * @param {boolean} event.data.useCustomCount - Whether to use a custom ticket count.\r\n * @param {number} event.data.ticketBuyCount - Custom ticket count.\r\n *\r\n * @example\r\n * handleMessage({\r\n *   data: {\r\n *     eventID: '123',\r\n *     threadDelay: 1000,\r\n *     requestTimeout: 5000,\r\n *     strictPriority: false,\r\n *     priorityItems: [{ value: 'VIP' }],\r\n *     bearerToken: 'your-token-here',\r\n *     useCustomCount: true,\r\n *     ticketBuyCount: 2\r\n *   }\r\n * });\r\n */\r\nconst handleMessage = ({\r\n  data: {\r\n    eventID,\r\n    threadDelay,\r\n    requestTimeout,\r\n    strictPriority,\r\n    priorityItems,\r\n    bearerToken,\r\n    useCustomCount,\r\n    ticketBuyCount,\r\n  },\r\n}) => {\r\n  setInterval(async () => {\r\n    const response = await getEventInformation(eventID, requestTimeout);\r\n\r\n    self.postMessage({ type: \"request_start\" });\r\n\r\n    if (response === null) return self.postMessage({ type: \"request_error\" });\r\n\r\n    const event = response.model;\r\n\r\n    // Check if there are any available variants\r\n    const availableVariants = event.variants.filter((variant) => {\r\n      return new Date(variant.dateSalesFrom) < new Date() && variant.availability > 0;\r\n    });\r\n\r\n    // If there are no matches, return\r\n    if (availableVariants.length === 0) return self.postMessage({ type: \"no_available_variants\" });\r\n\r\n    // Handle priority items\r\n    if (priorityItems.length > 0) {\r\n      const priorityHandled = handlePriorityItems(priorityItems, availableVariants, {\r\n        bearerToken,\r\n        requestTimeout,\r\n        useCustomCount,\r\n        ticketBuyCount,\r\n      });\r\n\r\n      if (!priorityHandled && strictPriority) return self.postMessage({ type: \"strict_skip\" });\r\n    }\r\n\r\n    // Select a random variant if there are no priority items\r\n    const variantId = Math.floor(Math.random() * availableVariants.length);\r\n    self.postMessage({\r\n      type: \"buy_attempt\",\r\n      value: availableVariants[variantId].name,\r\n    });\r\n\r\n    return reserveProductVariant({\r\n      bearerToken,\r\n      requestTimeout,\r\n      variant: availableVariants[variantId],\r\n      useCustomCount,\r\n      ticketBuyCount,\r\n    });\r\n  }, threadDelay);\r\n};\r\n\r\n/**\r\n * Handles priority items by attempting to reserve product variants that match the priority values.\r\n * Iterates through the priority items and looks for available variants that include the priority value in their name.\r\n * If a matching variant is found, it attempts to reserve it and returns `true`.\r\n * If no matching variants are found, it returns `false`.\r\n *\r\n * @param {Object[]} priorityItems - An array of priority items to be reserved first. Each item should have a `value` property representing the priority value.\r\n * @param {Object[]} availableVariants - An array of available product variants. Each variant should have a `name` property.\r\n * @param {Object} options - Options for reserving the product variant.\r\n * @param {string} options.bearerToken - Bearer token used to authenticate the request.\r\n * @param {number} options.requestTimeout - Timeout for the request in milliseconds.\r\n * @param {boolean} options.useCustomCount - Whether to use a custom ticket count.\r\n * @param {number} options.ticketBuyCount - Custom ticket count.\r\n *\r\n * @returns {boolean} Returns `true` if a priority item was handled (reserved), otherwise returns `false`.\r\n *\r\n * @example\r\n * const priorityItems = [{ value: 'VIP' }];\r\n * const availableVariants = [{ name: 'VIP Ticket', isProductVariantActive: true }];\r\n * const options = {\r\n *   bearerToken: 'your-token-here',\r\n *   requestTimeout: 5000,\r\n *   useCustomCount: true,\r\n *   ticketBuyCount: 2\r\n * };\r\n * const result = handlePriorityItems(priorityItems, availableVariants, options);\r\n * console.log(result); // Output: true\r\n */\r\nconst handlePriorityItems = (priorityItems, availableVariants, options) => {\r\n  for (const item of priorityItems) {\r\n    const { value } = item;\r\n    const variant = availableVariants.find((variant) =>\r\n      variant.name.toLowerCase().includes(value.toLowerCase())\r\n    );\r\n    if (variant != null) {\r\n      self.postMessage({ type: \"buy_attempt\", value: variant.name });\r\n      reserveProductVariant({ ...options, variant });\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n// Listen for messages from the main thread\r\nself.addEventListener(\"message\", handleMessage);\r\n"],"names":["AbortSignal","timeout","ms","ctrl","AbortController","setTimeout","close","signal","calculateXRequestedId","inventoryId","length","Error","strippedId","replace","EXTRA_ID","encodedString","i","xorResult","charCodeAt","String","fromCharCode","btoa","substring","reserveProductVariant","async","bearerToken","requestTimeout","variant","useCustomCount","ticketBuyCount","maxReservationCount","Math","min","availability","productVariantMaximumReservableQuantity","self","postMessage","type","cart","response","fetch","method","headers","Authorization","cache","ok","responseBody","json","reservations","model","map","reservation","console","error","status","statusText","getReservationState","includes","quantity","reservationSuccess","body","JSON","stringify","expectCart","toCancel","toCreate","createProductVariantReservation","handlePriorityItems","priorityItems","availableVariants","options","item","value","find","name","toLowerCase","addEventListener","data","eventID","threadDelay","strictPriority","setInterval","getEventInformation","variants","filter","Date","dateSalesFrom","variantId","floor","random"],"sourceRoot":""}