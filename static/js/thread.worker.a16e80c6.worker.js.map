{"version":3,"file":"static/js/thread.worker.a16e80c6.worker.js","mappings":"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","sources":["logic/thread.worker.js"],"sourcesContent":["// Original filename: thread.worker.js\r\n\r\nAbortSignal.timeout ??= function timeout(ms) {\r\n  const ctrl = new AbortController();\r\n  setTimeout(() => ctrl.close(), ms);\r\n  return ctrl.signal;\r\n};\r\n\r\n/**\r\n * Fetches the event data for a given event ID from the Kide API.\r\n *\r\n * @param {string} eventID - The ID of the event to fetch data for.\r\n * @param {number} [requestTimeout=5000] - Timeout for the request in milliseconds (default is 5000ms).\r\n *\r\n * @returns {Promise<Object|null>} Returns a promise that resolves to the event data object if successful, or `null` if an error occurred.\r\n * The returned object will contain the event details, including variants and other information.\r\n * If the response status is not 200, the function returns `null`.\r\n *\r\n * @throws {Error} Throws an error if the fetch request fails, which is caught and logged within the function.\r\n *\r\n * @example\r\n * getEventData('123', 3000)\r\n *   .then(eventData => console.log(eventData))\r\n *   .catch(error => console.error('An error occurred:', error));\r\n */\r\nconst getEventInformation = async (eventID, requestTimeout = 5000) => {\r\n  try {\r\n    const response = await fetch(`https://api.kide.app/api/products/${eventID}`, {\r\n      method: \"GET\",\r\n      headers: {\r\n        \"cache-control\": \"no-cache\",\r\n      },\r\n      signal: AbortSignal.timeout(requestTimeout),\r\n    });\r\n\r\n    if (response.ok) return response.json();\r\n  } catch (error) {\r\n    console.error(`Error fetching event data for eventID ${eventID}:`, error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Gets the current user's reservation data (shopping cart) from the Kide API\r\n * @param {string} bearerToken Bearer token used to authenticate the request\r\n * @param {number} requestTimeout Timeout for the request in milliseconds\r\n * @returns {null | string[]} Returns null if an error occurred, otherwise returns an array of inventory IDs\r\n * @throws {Error} Throws an error if the fetch request fails\r\n * @example\r\n * const reservations = await getReservationData(bearerToken: 'your-token-here', requestTimeout: 3000);\r\n * console.log(reservations); // Output: ['inventoryId1', 'inventoryId2', ...]\r\n */\r\nconst getReservationState = async ({ bearerToken, requestTimeout = 5000 }) => {\r\n  try {\r\n    const response = await fetch(\"https://api.kide.app/api/reservations\", {\r\n      method: \"GET\",\r\n      headers: {\r\n        Authorization: `Bearer ${bearerToken}`,\r\n        cache: \"no-cache\",\r\n      },\r\n      signal: AbortSignal.timeout(requestTimeout),\r\n    });\r\n\r\n    if (response.ok) {\r\n      const responseBody = await response.json();\r\n      const reservations = responseBody.model?.reservations;\r\n\r\n      if (reservations == null) return [];\r\n\r\n      const itemsInCart = reservations.map((reservation) => reservation.inventoryId);\r\n      return itemsInCart;\r\n    } else {\r\n      console.error(`Error fetching reservations: ${response.status} ${response.statusText}`);\r\n    }\r\n  } catch (error) {\r\n    console.error(\"An error occurred while fetching reservations:\", error);\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Creates a reservation for a product variant\r\n * @param {string} bearerToken Bearer token used to authenticate the request\r\n * @param {string} inventoryId Inventory ID of the product variant\r\n * @param {number} quantity Quantity of the product variant to reserve\r\n * @param {number} requestTimeout Timeout for the request in milliseconds\r\n * @returns {boolean} Returns true if the reservation was successful, otherwise returns false\r\n * @example\r\n * const reservationSuccess = await createProductVariantReservation({\r\n      bearerToken: 'your-token-here',\r\n      inventoryId: 'inventory-id-here',\r\n      quantity: 3,\r\n      requestTimeout: 3000,\r\n    });\r\n * console.log(reservationSuccess); // Output: true\r\n */\r\nconst createProductVariantReservation = async ({\r\n  bearerToken,\r\n  inventoryId,\r\n  quantity,\r\n  requestTimeout,\r\n}) => {\r\n  const response = await fetch(\"https://api.kide.app/api/reservations\", {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n      Authorization: `Bearer ${bearerToken}`,\r\n      cache: \"no-cache\", // Corrected header name\r\n    },\r\n    body: JSON.stringify({\r\n      toCancel: [],\r\n      toCreate: [\r\n        {\r\n          inventoryId: inventoryId,\r\n          productVariantUserForm: null,\r\n          quantity: String(quantity),\r\n        },\r\n      ],\r\n    }),\r\n    signal: AbortSignal.timeout(requestTimeout),\r\n  });\r\n  return response.ok;\r\n};\r\n\r\n/**\r\n * Reserves a product variant\r\n * @param {string} bearerToken Bearer token used to authenticate the request\r\n * @param {number} requestTimeout Timeout for the request in milliseconds\r\n * @param {object} variant Product variant object\r\n * @param {boolean} useCustomCount Whether to use a custom ticket count\r\n * @param {number} ticketBuyCount Custom ticket count\r\n * @returns {undefined} The function does not return value\r\n */\r\nconst reserveProductVariant = async ({\r\n  bearerToken,\r\n  requestTimeout = 5000,\r\n  variant,\r\n  useCustomCount = false,\r\n  ticketBuyCount = 0,\r\n} = {}) => {\r\n  try {\r\n    const maxReservationCount = Math.min(\r\n      variant.availability,\r\n      variant.productVariantMaximumReservableQuantity\r\n    );\r\n\r\n    if (maxReservationCount === 0) return self.postMessage({ type: \"buy_failed\" });\r\n\r\n    const cart = await getReservationState({\r\n      bearerToken: bearerToken,\r\n      requestTimeout: requestTimeout,\r\n    });\r\n\r\n    // If the cart is null the request has failed, return\r\n    if (cart === null || typeof cart === \"undefined\") {\r\n      return self.postMessage({ type: \"request_error\" });\r\n    } else {\r\n      self.postMessage({ type: \"request_success\" });\r\n    }\r\n\r\n    // If the item is already in the cart, return\r\n    if (cart.includes(variant.inventoryId)) return self.postMessage({ type: \"in_cart\" });\r\n\r\n    const quantity = useCustomCount\r\n      ? Math.min(ticketBuyCount, maxReservationCount)\r\n      : maxReservationCount;\r\n\r\n    // Attempt to reserve the item\r\n    const reservationSuccess = await createProductVariantReservation({\r\n      bearerToken: bearerToken,\r\n      inventoryId: variant.inventoryId,\r\n      quantity: quantity,\r\n      requestTimeout: requestTimeout,\r\n    });\r\n\r\n    // If the reservation failed, return\r\n    if (!reservationSuccess) return self.postMessage({ type: \"buy_failed\" });\r\n\r\n    // The reservation was successful\r\n    self.postMessage({ type: \"buy_success\" });\r\n  } catch (error) {\r\n    console.error(\"An error occurred while processing the shopping request:\", error);\r\n    self.postMessage({ type: \"buy_failed\" });\r\n  }\r\n};\r\n\r\n/**\r\n * Handles an event message by repeatedly attempting to reserve product variants.\r\n * The function first attempts to reserve priority items if provided, and then randomly selects available variants.\r\n * The interval for attempting reservations is controlled by the `threadDelay` parameter.\r\n *\r\n * @param {Object} event - The event object containing the data for handling the message.\r\n * @param {string} event.data.eventID - The ID of the event to handle.\r\n * @param {number} event.data.threadDelay - The delay in milliseconds between attempts to reserve product variants.\r\n * @param {number} event.data.requestTimeout - Timeout for the request in milliseconds.\r\n * @param {boolean} event.data.strictPriority - Whether to strictly follow priority items and skip others if priority items are present.\r\n * @param {Object[]} event.data.priorityItems - An array of priority items to be reserved first.\r\n * @param {string} event.data.bearerToken - Bearer token used to authenticate the request.\r\n * @param {boolean} event.data.useCustomCount - Whether to use a custom ticket count.\r\n * @param {number} event.data.ticketBuyCount - Custom ticket count.\r\n *\r\n * @example\r\n * handleMessage({\r\n *   data: {\r\n *     eventID: '123',\r\n *     threadDelay: 1000,\r\n *     requestTimeout: 5000,\r\n *     strictPriority: false,\r\n *     priorityItems: [{ value: 'VIP' }],\r\n *     bearerToken: 'your-token-here',\r\n *     useCustomCount: true,\r\n *     ticketBuyCount: 2\r\n *   }\r\n * });\r\n */\r\nconst handleMessage = ({\r\n  data: {\r\n    eventID,\r\n    threadDelay,\r\n    requestTimeout,\r\n    strictPriority,\r\n    priorityItems,\r\n    bearerToken,\r\n    useCustomCount,\r\n    ticketBuyCount,\r\n  },\r\n}) => {\r\n  setInterval(async () => {\r\n    const response = await getEventInformation(eventID, requestTimeout);\r\n\r\n    self.postMessage({ type: \"request_start\" });\r\n\r\n    if (response === null) return self.postMessage({ type: \"request_error\" });\r\n\r\n    const event = response.model;\r\n    const availableVariants = event.variants.filter((variant) => variant.isProductVariantActive);\r\n\r\n    // If there are no matches, return\r\n    if (availableVariants.length === 0) return self.postMessage({ type: \"no_available_variants\" });\r\n\r\n    // Handle priority items\r\n    if (priorityItems.length > 0) {\r\n      const priorityHandled = handlePriorityItems(priorityItems, availableVariants, {\r\n        bearerToken,\r\n        requestTimeout,\r\n        useCustomCount,\r\n        ticketBuyCount,\r\n      });\r\n\r\n      if (!priorityHandled && strictPriority) return self.postMessage({ type: \"strict_skip\" });\r\n    }\r\n\r\n    // Select a random variant if there are no priority items\r\n    const variantId = Math.floor(Math.random() * availableVariants.length);\r\n    self.postMessage({\r\n      type: \"buy_attempt\",\r\n      value: availableVariants[variantId].name,\r\n    });\r\n\r\n    return reserveProductVariant({\r\n      bearerToken,\r\n      requestTimeout,\r\n      variant: availableVariants[variantId],\r\n      useCustomCount,\r\n      ticketBuyCount,\r\n    });\r\n  }, threadDelay);\r\n};\r\n\r\n/**\r\n * Handles priority items by attempting to reserve product variants that match the priority values.\r\n * Iterates through the priority items and looks for available variants that include the priority value in their name.\r\n * If a matching variant is found, it attempts to reserve it and returns `true`.\r\n * If no matching variants are found, it returns `false`.\r\n *\r\n * @param {Object[]} priorityItems - An array of priority items to be reserved first. Each item should have a `value` property representing the priority value.\r\n * @param {Object[]} availableVariants - An array of available product variants. Each variant should have a `name` property.\r\n * @param {Object} options - Options for reserving the product variant.\r\n * @param {string} options.bearerToken - Bearer token used to authenticate the request.\r\n * @param {number} options.requestTimeout - Timeout for the request in milliseconds.\r\n * @param {boolean} options.useCustomCount - Whether to use a custom ticket count.\r\n * @param {number} options.ticketBuyCount - Custom ticket count.\r\n *\r\n * @returns {boolean} Returns `true` if a priority item was handled (reserved), otherwise returns `false`.\r\n *\r\n * @example\r\n * const priorityItems = [{ value: 'VIP' }];\r\n * const availableVariants = [{ name: 'VIP Ticket', isProductVariantActive: true }];\r\n * const options = {\r\n *   bearerToken: 'your-token-here',\r\n *   requestTimeout: 5000,\r\n *   useCustomCount: true,\r\n *   ticketBuyCount: 2\r\n * };\r\n * const result = handlePriorityItems(priorityItems, availableVariants, options);\r\n * console.log(result); // Output: true\r\n */\r\nconst handlePriorityItems = (priorityItems, availableVariants, options) => {\r\n  for (const item of priorityItems) {\r\n    const { value } = item;\r\n    const variant = availableVariants.find((variant) =>\r\n      variant.name.toLowerCase().includes(value.toLowerCase())\r\n    );\r\n    if (variant != null) {\r\n      self.postMessage({ type: \"buy_attempt\", value: variant.name });\r\n      reserveProductVariant({ ...options, variant });\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n// Listen for messages from the main thread\r\nself.addEventListener(\"message\", handleMessage);\r\n"],"names":["AbortSignal","timeout","ms","ctrl","AbortController","setTimeout","close","signal","reserveProductVariant","async","bearerToken","requestTimeout","variant","useCustomCount","ticketBuyCount","maxReservationCount","Math","min","availability","productVariantMaximumReservableQuantity","self","postMessage","type","cart","response","fetch","method","headers","Authorization","cache","ok","responseBody","json","reservations","model","map","reservation","inventoryId","console","error","status","statusText","getReservationState","includes","quantity","reservationSuccess","body","JSON","stringify","toCancel","toCreate","productVariantUserForm","String","createProductVariantReservation","handlePriorityItems","priorityItems","availableVariants","options","item","value","find","name","toLowerCase","addEventListener","data","eventID","threadDelay","strictPriority","setInterval","getEventInformation","variants","filter","isProductVariantActive","length","variantId","floor","random"],"sourceRoot":""}